## 第六周作业

---

### 作业

- 必做题：`user-commdi-order.sql`为必做题的用户，商品，订单库表sql，共有四张表:用户表(**user**)，商品表(**commodity**)，订单表(**order**)，订单明细表(**order_detail**)

  - `user表`: *主键自增*，bigint(32) unsigned，用户信息属于读多写少的冷数据，作为登录信息，还具备手机号，邮箱，用户名登陆等，限制唯一性，对`phone,mail`添加了唯一索引，对`id_card`身份证也添加了唯一索引；不确定对于用户信息还会有哪些查找的场景，没有加其他的索引 

    ---

  - `commodity`表: *主键自增*，bigint(32) unsigned 

    -  先按照自己的印象，想了一下一个商品应该具备哪些基本属性，像在天猫哪些购物网站上看到的商品标题，除了一个商品原本的名称，附加了一些其他的描述，或是品牌，或是推销描述，或是优惠信息之类的，所以在`first_name`字段后，加了个`sub_name`，类似于副标题一样的东西；

    - 然后就是商品具备的基础信息：sku，库存，价格，销售价，封面图，描述信息等。

      - 再去天猫看了一下商品的信息展示，如果是类似于这种中间平台的的网站，一样的商品可能有很多家店铺在销售，又加了个`store_id,store_name`字段；还有就是商品的sku信息，sku 表示商品属性的聚合，一件商品附上多个 sku 信息，就是作为多个销售商品存在，以 `基本的商品信息 + 一个sku`标识一个唯一的商品，`sku_id`对应(*现在没有的* )sku表的id，`sku_info` 是sku属性的合集，理解为一个 json 串也行，不过我觉得商品的sku应该是由两个部分的：参与商品销售属性的，只作为信息展示的；前者是商品的尺码，容量，颜色这种由用户选择的属性，后者是作为商品详情展示的一部分：

        - >例如： 小米(死活抢不到的)K30至尊纪念版，内存，材质，存储大小这些可能影响销售价格的sku属性；重量，尺寸，产地，电池规格，摄像头信息这种只作为产品说明展示的属性 

        没有设计过sku的表，不知道这种结构该怎么定义，一个sku如果是多个单纯属性的笛卡尔集，那比较好理解，但是对于固定字段的表结构来说，如果一个规格的sku一张表，数量有点大；

      - 商品本身是可以具备类别的：一级分类，二级分类...，sku 信息如果也对应的商品分类，存在多级 sku ，那一个商品取各级分类下的 sku 再加上一些独有的 sku 属性，就可以排列组合出商品所需要的详细sku信息。抽象地说：提取大分类下的商品`共性`，然后再加上具体商品的`个性`，最后组合成商品的 sku，这个方向是对的？(//TODO)

      - `冗余字段`： 商品的`store_name,full_name,sku_info`是我认为的冗余出来的字段，都是和商品关联，作为商品信息展示，但是可以不用每次展示都去关联数据库查询的信息，只需要有更新即可。

    - `索引`：

      - 从商品被搜索的方向考虑 ：一般是商品名称最多，品牌，然后可能是店铺，商品的时间排序，价格排序等；所以添加了`sale_price`的普通索引，`商品名称，品牌信息，上架时间，更新时间`的组合索引，按照可能被搜索的频率排序，`上架时间,更新时间`的组合索引，防止第二个索引无法匹配。
      - 对`id,sku_id`添加了唯一索引，防止商品重复创建，以及商家通过sku搜索商品的情况 

      ---

  - `order,order_detail`表：**这里仅仅是从用户角度考虑的订单信息，不是商家**

    - `order` 表：

      - 非自增的 varchar(64) 主键，订单无疑是电商中写最频繁的数据，单纯的自增主键可能不利于扩展，在多库的情况下，控制自增id不冲突也是个问题，如果是我们自己生成id，还可以用hash算法让id落到不同的库上再进行生成，单库上id不冲突就相对好解决很多；
      - 订单为了展示信息，应该避免通过id关联去进行二次查询，例如用户的信息，商品信息，优惠信息，快递方信息等，所以这里也冗余了一些字段：
        - `user_name,nick_name,phone,rece_addr` ： 用户的这部分信息在订单中生成就固定，订单展示的时候不需要再去进行查询
        - `shipping,order_price,discount,track_name,`：运费，订单总金额，优惠金额，快递方信息，是可以通过计算和关联查询的信息，也冗余出来，方便展示
      - `索引`: 从用户的角度搜索订单
        - `user_id`：这个索引是查询用户订单必须的
        - `status,create_time,update_time` ：组合索引是为了基于状态和下单时间对订单搜索，然后获得订单id关联查询`order_detail`表

    - `order_detail` 表：

      - 非自增的 varchar(64) 主键，和 `order`表类似，订单详情的记录只会大于订单的记录，因此主键也不是自增的
      - 订单详情里面记录了商品交易时的快照，而不是通过商品ID再次去查询
      - 索引：
        - `idx_order_name` : 用户根据商品名称搜索订单是常见的需求，其次可能是搜索店铺名称，因此组合索引 `comdi_name` 排在 `store_name` 之前
        - `idx_order_time` : 根据下单时间搜索订单也是很常见的，这里没有订单状态，是因为订单状态放在了外面，想到这儿感觉有点不对：**一个订单里面的多个商品，也就是对应的多个订单详情，是有可能存在部分退货/退款的，这里缺了个订单详情状态字段**，
        - `idx_order` : 订单详情关联订单Id ，这也是必须的索引

      ---

  - //TODO 